# Доказательство алгоритмической сложности метода `simulate`

## Сложность метода зависит от следующих этапов:

### 1. Сортировка юнитов перед каждым раундом
Перед началом каждого раунда юниты обеих армий сортируются по значению `baseAttack` в порядке убывания.
- **Сложность сортировки:** \(O(k \cdot \log k)\), где \(k\) — общее количество юнитов в армии.
- Поскольку сортировка выполняется дважды (для армии игрока и компьютера):

\[
O(k \cdot \log k + k \cdot \log k) = O(k \cdot \log k)
\]

### 2. Обработка очереди ходов
Для выполнения атак используется очередь, где юниты ходят по убыванию `baseAttack`.
- Каждая операция добавления/извлечения из очереди занимает \(O(\log k)\).
- Всего в очереди \(k\) юнитов.
- Обработка всех ходов:

\[
O(k \cdot \log k)
\]

### 3. Атака юнитов
Каждая атака выполняется за \(O(1)\), включая вызов `unit.getProgram().attack()` и проверку статуса цели.
- В худшем случае, каждый юнит выполняет одну атаку в каждом раунде.
- Обработка атак для \(k\) юнитов в раунде:

\[
O(k)
\]

### 4. Число раундов
Общее количество раундов зависит от числа юнитов, поскольку в каждом раунде может быть уничтожен хотя бы один юнит.
- В худшем случае, общее число раундов пропорционально \(k\).
- Цикл раундов:

\[
O(k)
\]

## Итоговая сложность
- В каждом раунде выполняются сортировка, обработка очереди и атаки, что занимает:

\[
O(k \cdot \log k + k \cdot \log k + k) = O(k \cdot \log k)
\]
- Учитывая, что всего \(k\) раундов:

\[
O(k \cdot (k \cdot \log k)) = O(k^2 \cdot \log k)
\]

## Доказательство

### Этапы алгоритма:
1. **Сортировка:** \(O(k \cdot \log k)\).
2. **Очередь:** \(O(k \cdot \log k)\).
3. **Атаки:** \(O(k)\).
4. **Цикл раундов:** \(O(k)\).

### Итоговая сложность каждого раунда:
\[
O(k \cdot \log k)
\]

### Общее число раундов:
\[
k \text{ (в худшем случае).}
\]

### Итоговая сложность алгоритма:
\[
O(k^2 \cdot \log k)
\]

## Вывод
Алгоритм имеет сложность \(O(k^2 \cdot \log k)\), что соответствует требованиям задачи.
